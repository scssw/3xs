{{define "modals/inboundModal"}}
<a-modal id="inbound-modal" v-model="inModal.visible" :dialog-style="{ top: '20px' }"
    @ok="inModal.ok" :confirm-loading="inModal.confirmLoading" :closable="true" :mask-closable="false"
    :class="themeSwitcher.currentTheme" :ok-text="inModal.okText" cancel-text='{{ i18n "close" }}'>
    <template slot="title">
        <div :style="{ display: 'flex', alignItems: 'center', gap: '8px' }">
            <a-button type="primary" size="small" @click="inModal.ok">[[ inModal.okText ]]</a-button>
            <span>[[ inModal.title ]]</span>
        </div>
    </template>
    {{template "form/inbound"}}
</a-modal>
<script>

    const INBOUND_TRAFFIC_EXPIRY_MAP = new Map([
        [50, 1],
        [150, 3],
        [300, 6],
        [600, 12],
    ]);
    const SINGLE_PORT_MULTI_USER_STORAGE_KEY = 'singlePortMultiUserEnabled';

    // Make inModal globally available to ensure it works with any base path
    const inModal = window.inModal = {
        title: '',
        visible: false,
        confirmLoading: false,
        okText: '{{ i18n "sure" }}',
        isEdit: false,
        confirm: null,
        inbound: new Inbound(),
        dbInbound: new DBInbound(),
        ok() {
            ObjectUtil.execute(inModal.confirm, inModal.inbound, inModal.dbInbound);
        },
        show({ title = '', okText = '{{ i18n "sure" }}', inbound = null, dbInbound = null, confirm = (inbound, dbInbound) => { }, isEdit = false }) {
            this.title = title;
            this.okText = okText;
            if (inbound) {
                this.inbound = Inbound.fromJson(inbound.toJson());
            } else {
                this.inbound = new Inbound();
            }
            // Always ensure testseed is initialized for VLESS protocol (even if vision flow is not set yet)
            // This ensures Vue reactivity works properly
            if (this.inbound.protocol === Protocols.VLESS && this.inbound.settings) {
                if (!this.inbound.settings.testseed || !Array.isArray(this.inbound.settings.testseed) || this.inbound.settings.testseed.length < 4) {
                    // Create a new array to ensure Vue reactivity
                    this.inbound.settings.testseed = [900, 500, 900, 256].slice();
                }
            }
            if (dbInbound) {
                this.dbInbound = new DBInbound(dbInbound);
            } else {
                this.dbInbound = new DBInbound();
            }
            this.confirm = confirm;
            this.visible = true;
            this.isEdit = isEdit;
        },
        close() {
            inModal.visible = false;
            inModal.loading(false);
        },
        loading(loading = true) {
            inModal.confirmLoading = loading;
        },
        // Vision Seed methods - always available regardless of Vue context
        updateTestseed(index, value) {
            // Use inModal.inbound explicitly to ensure correct context
            if (!inModal.inbound || !inModal.inbound.settings) return;
            // Ensure testseed is initialized
            if (!inModal.inbound.settings.testseed || !Array.isArray(inModal.inbound.settings.testseed)) {
                inModal.inbound.settings.testseed = [900, 500, 900, 256];
            }
            // Ensure array has enough elements
            while (inModal.inbound.settings.testseed.length <= index) {
                inModal.inbound.settings.testseed.push(0);
            }
            // Update value
            inModal.inbound.settings.testseed[index] = value;
        },
        setRandomTestseed() {
            // Use inModal.inbound explicitly to ensure correct context
            if (!inModal.inbound || !inModal.inbound.settings) return;
            // Ensure testseed is initialized
            if (!inModal.inbound.settings.testseed || !Array.isArray(inModal.inbound.settings.testseed) || inModal.inbound.settings.testseed.length < 4) {
                inModal.inbound.settings.testseed = [900, 500, 900, 256].slice();
            }
            // Create new array with random values
            inModal.inbound.settings.testseed = [Math.floor(Math.random()*1000), Math.floor(Math.random()*1000), Math.floor(Math.random()*1000), Math.floor(Math.random()*1000)];
        },
        resetTestseed() {
            // Use inModal.inbound explicitly to ensure correct context
            if (!inModal.inbound || !inModal.inbound.settings) return;
            // Reset testseed to default values
            inModal.inbound.settings.testseed = [900, 500, 900, 256].slice();
        }
    };

    // Store Vue instance globally to ensure methods are always accessible
    let inboundModalVueInstance = null;
    
    inboundModalVueInstance = new Vue({
        delimiters: ['[[', ']]'],
        el: '#inbound-modal',
        data: {
            inModal: inModal,
            delayedStart: false,
            singlePortMultiUser: false,
            storedInboundTotalGB: null,
            storedInboundExpiryTime: null,
            get inbound() {
                return inModal.inbound;
            },
            get dbInbound() {
                return inModal.dbInbound;
            },
            get isEdit() {
                return inModal.isEdit;
            },
            get client() {
                return inModal.inbound && inModal.inbound.clients && inModal.inbound.clients.length > 0 ? inModal.inbound.clients[0] : null;
            },
            get clientTotalGB() {
                return this.client ? this.client._totalGB : null;
            },
            get clientExpiryTime() {
                return this.client ? this.client._expiryTime : null;
            },
            get datepicker() {
                return app.datepicker;
            },
            get delayedExpireDays() {
                return this.client && this.client.expiryTime < 0 ? this.client.expiryTime / -86400000 : 0;
            },
            set delayedExpireDays(days) {
                this.client.expiryTime = -86400000 * days;
            },
            get externalProxy() {
                return this.inbound.stream.externalProxy.length > 0;
            },
            set externalProxy(value) {
                if (value) {
                    inModal.inbound.stream.externalProxy = [{
                        forceTls: "same",
                        dest: window.location.hostname,
                        port: inModal.inbound.port,
                        remark: ""
                    }];
                } else {
                    inModal.inbound.stream.externalProxy = [];
                }
            }
        },
        watch: {
            'inModal.visible'(isVisible) {
                if (!isVisible) return;
                if (this.isEdit) return;
                this.storedInboundTotalGB = null;
                this.storedInboundExpiryTime = null;
                this.applyInboundDefaults();
                const stored = localStorage.getItem(SINGLE_PORT_MULTI_USER_STORAGE_KEY);
                this.singlePortMultiUser = stored === 'true';
            },
            singlePortMultiUser(newVal, oldVal) {
                if (this.isEdit) return;
                if (newVal === oldVal) return;
                localStorage.setItem(SINGLE_PORT_MULTI_USER_STORAGE_KEY, newVal ? 'true' : 'false');
                if (newVal) {
                    if (this.storedInboundTotalGB === null) {
                        this.storedInboundTotalGB = this.dbInbound.totalGB;
                        this.storedInboundExpiryTime = this.dbInbound._expiryTime;
                    }
                    this.dbInbound.totalGB = 0;
                    this.dbInbound._expiryTime = null;
                    this.applyClientDefaultsOn();
                } else {
                    if (this.storedInboundTotalGB !== null) {
                        this.dbInbound.totalGB = this.storedInboundTotalGB;
                        this.dbInbound._expiryTime = this.storedInboundExpiryTime;
                    }
                    this.applyClientDefaultsOff();
                }
            },
            'inModal.inbound.port'() {
                this.applyClientEmailDefault();
            },
            'inModal.dbInbound.totalGB'(newVal) {
                if (this.singlePortMultiUser) return;
                this.applyTrafficExpiryRule(newVal);
                if (!this.isEdit) {
                    this.applyClientDefaultsOff();
                }
            },
            'inModal.dbInbound._expiryTime'(newVal) {
                if (!this.singlePortMultiUser && !this.isEdit) {
                    const client = this.getPrimaryClient();
                    if (client) {
                        client._expiryTime = newVal;
                    }
                }
                this.applyClientEmailDefault();
            },
            clientTotalGB(newVal) {
                if (this.isEdit) return;
                if (!this.singlePortMultiUser) return;
                this.applyClientExpiryRule(newVal);
            },
            clientExpiryTime() {
                this.applyClientEmailDefault();
            },
            'inModal.inbound.stream.security'(newVal, oldVal) {
                // Clear flow when security changes from reality/tls to none
                if (inModal.inbound.protocol == Protocols.VLESS && !inModal.inbound.canEnableTlsFlow()) {
                    inModal.inbound.settings.vlesses.forEach(client => {
                        client.flow = "";
                    });
                }
            },
            // Ensure testseed is always initialized when vision flow is enabled
            'inModal.inbound.settings.vlesses': {
                handler() {
                    if (inModal.inbound.protocol === Protocols.VLESS && inModal.inbound.settings && inModal.inbound.settings.vlesses) {
                        const hasVisionFlow = inModal.inbound.settings.vlesses.some(c => c.flow === 'xtls-rprx-vision' || c.flow === 'xtls-rprx-vision-udp443');
                        if (hasVisionFlow && (!inModal.inbound.settings.testseed || !Array.isArray(inModal.inbound.settings.testseed) || inModal.inbound.settings.testseed.length < 4)) {
                            inModal.inbound.settings.testseed = [900, 500, 900, 256];
                        }
                    }
                },
                deep: true
            }
        },
        methods: {
            getTrafficExpiryMonths(totalGB) {
                const normalized = Number(totalGB);
                if (!Number.isFinite(normalized)) return null;
                return INBOUND_TRAFFIC_EXPIRY_MAP.get(normalized) ?? null;
            },
            applyTrafficExpiryRule(totalGB) {
                const months = this.getTrafficExpiryMonths(totalGB);
                if (!months || typeof moment === 'undefined') return;
                this.dbInbound._expiryTime = moment().add(months, 'months');
            },
            getPrimaryClient() {
                const clients = this.inbound ? this.inbound.clients : null;
                if (!clients || !Array.isArray(clients) || clients.length === 0) return null;
                return clients[0];
            },
            getHostPrefix() {
                const host = (window.location && window.location.hostname) ? window.location.hostname : '';
                if (!host) return 'HOST';
                return host.split('.')[0].split(':')[0].toUpperCase();
            },
            getExpiryLabel(expiryTime) {
                if (!expiryTime) return '0.0';
                if (typeof moment !== 'undefined' && moment.isMoment(expiryTime)) {
                    return `${expiryTime.month() + 1}.${expiryTime.date()}`;
                }
                const dateValue = typeof expiryTime === 'number' ? expiryTime : new Date(expiryTime).getTime();
                if (!Number.isFinite(dateValue)) return '0.0';
                const date = new Date(dateValue);
                return `${date.getMonth() + 1}.${date.getDate()}`;
            },
            applyClientExpiryRule(totalGB) {
                if (this.isEdit) return;
                const client = this.getPrimaryClient();
                if (!client) return;
                const months = this.getTrafficExpiryMonths(totalGB);
                if (!months || typeof moment === 'undefined') return;
                client._expiryTime = moment().add(months, 'months');
                this.applyClientEmailDefault();
            },
            applyClientEmailDefault() {
                if (this.isEdit) return;
                const client = this.getPrimaryClient();
                if (!client) return;
                const prefix = this.getHostPrefix();
                const port = this.inbound ? this.inbound.port : '';
                const expirySource = this.singlePortMultiUser ? client._expiryTime : this.dbInbound._expiryTime;
                const expiryLabel = this.getExpiryLabel(expirySource);
                client.email = `${prefix}:${port}-${expiryLabel}`;
            },
            applyClientDefaultsOn() {
                const client = this.getPrimaryClient();
                if (!client) return;
                client._totalGB = 50;
                this.applyClientExpiryRule(50);
            },
            applyClientDefaultsOff() {
                const client = this.getPrimaryClient();
                if (!client) return;
                const inboundTotal = Number.isFinite(this.dbInbound.totalGB) ? this.dbInbound.totalGB : 0;
                client._totalGB = inboundTotal;
                client._expiryTime = this.dbInbound._expiryTime || null;
                this.applyClientEmailDefault();
            },
            applyInboundDefaults() {
                this.dbInbound.totalGB = 50;
                this.applyTrafficExpiryRule(50);
                this.applyClientDefaultsOff();
                if (this.inbound && this.inbound.canEnableReality && this.inbound.canEnableReality()) {
                    this.inbound.stream.security = 'reality';
                    this.$nextTick(() => {
                        if (this.inbound.stream.security === 'reality') {
                            this.getNewX25519Cert();
                        }
                    });
                }
            },
            streamNetworkChange() {
                if (!inModal.inbound.canEnableTls()) {
                    this.inModal.inbound.stream.security = 'none';
                }
                if (!inModal.inbound.canEnableReality()) {
                    this.inModal.inbound.reality = false;
                }
                if (this.inModal.inbound.protocol == Protocols.VLESS && !inModal.inbound.canEnableTlsFlow()) {
                    this.inModal.inbound.settings.vlesses.forEach(client => {
                        client.flow = "";
                    });
                }
            },
            SSMethodChange() {
                this.inModal.inbound.settings.password = RandomUtil.randomShadowsocksPassword(this.inModal.inbound.settings.method)

                if (this.inModal.inbound.isSSMultiUser) {
                    if (this.inModal.inbound.settings.shadowsockses.length == 0) {
                        this.inModal.inbound.settings.shadowsockses = [new Inbound.ShadowsocksSettings.Shadowsocks()];
                    }
                    if (!this.inModal.inbound.isSS2022) {
                        this.inModal.inbound.settings.shadowsockses.forEach(client => {
                            client.method = this.inModal.inbound.settings.method;
                        })
                    } else {
                        this.inModal.inbound.settings.shadowsockses.forEach(client => {
                            client.method = "";
                        })
                    }
                    this.inModal.inbound.settings.shadowsockses.forEach(client => {
                        client.password = RandomUtil.randomShadowsocksPassword(this.inModal.inbound.settings.method)
                    })
                } else {
                    if (this.inModal.inbound.settings.shadowsockses.length > 0) {
                        this.inModal.inbound.settings.shadowsockses = [];
                    }
                }
            },
            setDefaultCertData(index) {
                inModal.inbound.stream.tls.certs[index].certFile = app.defaultCert;
                inModal.inbound.stream.tls.certs[index].keyFile = app.defaultKey;
            },
            async getNewX25519Cert() {
                inModal.loading(true);
                const msg = await HttpUtil.get('/panel/api/server/getNewX25519Cert');
                inModal.loading(false);
                if (!msg.success) {
                    return;
                }
                inModal.inbound.stream.reality.privateKey = msg.obj.privateKey;
                inModal.inbound.stream.reality.settings.publicKey = msg.obj.publicKey;
            },
            clearX25519Cert() {
                this.inbound.stream.reality.privateKey = '';
                this.inbound.stream.reality.settings.publicKey = '';
            },
            async getNewmldsa65() {
                inModal.loading(true);
                const msg = await HttpUtil.get('/panel/api/server/getNewmldsa65');
                inModal.loading(false);
                if (!msg.success) {
                    return;
                }
                inModal.inbound.stream.reality.mldsa65Seed = msg.obj.seed;
                inModal.inbound.stream.reality.settings.mldsa65Verify = msg.obj.verify;
            },
            clearMldsa65() {
                this.inbound.stream.reality.mldsa65Seed = '';
                this.inbound.stream.reality.settings.mldsa65Verify = '';
            },
            randomizeRealityTarget() {
                if (typeof getRandomRealityTarget !== 'undefined') {
                    const randomTarget = getRandomRealityTarget();
                    this.inbound.stream.reality.target = randomTarget.target;
                    this.inbound.stream.reality.serverNames = randomTarget.sni;
                }
            },
            async getNewEchCert() {
                inModal.loading(true);
                const msg = await HttpUtil.post('/panel/api/server/getNewEchCert', { sni: inModal.inbound.stream.tls.sni });
                inModal.loading(false);
                if (!msg.success) {
                    return;
                }
                inModal.inbound.stream.tls.echServerKeys = msg.obj.echServerKeys;
                inModal.inbound.stream.tls.settings.echConfigList = msg.obj.echConfigList;
            },
            clearEchCert() {
                this.inbound.stream.tls.echServerKeys = '';
                this.inbound.stream.tls.settings.echConfigList = '';
            },
            async getNewVlessEnc() {
                inModal.loading(true);
                const msg = await HttpUtil.get('/panel/api/server/getNewVlessEnc');
                inModal.loading(false);

                if (!msg.success) {
                    return;
                }

                const auths = msg.obj.auths || [];
                const selected = inModal.inbound.settings.selectedAuth;
                const block = auths.find(a => a.label === selected);

                if (!block) {
                    console.error("No auth block for", selected);
                    return;
                }

                inModal.inbound.settings.decryption = block.decryption;
                inModal.inbound.settings.encryption = block.encryption;
            },
            clearVlessEnc() {
                this.inbound.settings.decryption = 'none';
                this.inbound.settings.encryption = 'none';
                this.inbound.settings.selectedAuth = undefined;
            },
            // Vision Seed methods - must be in Vue methods for proper binding
            updateTestseed(index, value) {
                // Ensure testseed is initialized
                if (!this.inbound.settings.testseed || !Array.isArray(this.inbound.settings.testseed)) {
                    this.$set(this.inbound.settings, 'testseed', [900, 500, 900, 256]);
                }
                // Ensure array has enough elements
                while (this.inbound.settings.testseed.length <= index) {
                    this.inbound.settings.testseed.push(0);
                }
                // Update value using Vue.set for reactivity
                this.$set(this.inbound.settings.testseed, index, value);
            },
            setRandomTestseed() {
                // Create new array with random values and use Vue.set for reactivity
                const newSeed = [Math.floor(Math.random()*1000), Math.floor(Math.random()*1000), Math.floor(Math.random()*1000), Math.floor(Math.random()*1000)];
                this.$set(this.inbound.settings, 'testseed', newSeed);
            },
            resetTestseed() {
                // Reset testseed to default values using Vue.set for reactivity
                this.$set(this.inbound.settings, 'testseed', [900, 500, 900, 256]);
            }
        },
    });

</script>
{{end}}
